{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/","title":"API Reference","text":"<p>Here you can find the API specification for Qadence 2 IR. There is a page for each module in the Qadence 2 IR package, in which all class and function definitions are documented. The API reference is particularly useful to check the behavior of classes and functions, and to get information on arguments, attributes and other details.</p> <p>Qadence 2 IR has 5 modules that are each responsible for different aspects of the IR. For more information, see their dedicated pages:</p> <ul> <li><code>qadence2-ir.factory</code>: Defines a factory function that creates a compile function.</li> <li><code>qadence2-ir.types</code>: Defines the valid types to be used in Qadence 2 IR code.</li> <li><code>qadence2-ir.irast</code>: Defines the AST that is used in front-end to IR compilation.</li> <li><code>qadence2-ir.irbuilder</code>: Defines the interface for front-ends compilation.</li> <li><code>qadence2-ir.factory_tools</code>: Defines tools for processing AST objects during compilation.</li> </ul>"},{"location":"api/factory/","title":"Factory","text":"<p>This module defines a factory method that creates a compiler function based on an <code>IRBuilder</code>.</p> <p>The compiler function, that can be generated using the factory, should be used to to compile a certain type of input, based on the front-end that is being used, to IR code. This is the first step of compilation, which is followed by a compilation from IR to the targeted backend.</p>"},{"location":"api/factory/#qadence2_ir.factory.ir_compiler_factory","title":"<code>ir_compiler_factory(builder)</code>","text":"<p>Constructs an IR compiler function for a specific input type by using an <code>IRBuilder</code>.</p> <p>The factory function uses an <code>IRBuilder[InputType]</code> to create an IR compiler function that converts an input of type <code>InputType</code> and returns a Model. The IR compiler must be named 'compile_to_model' by convention to ensure accessibility to other engines in the framework.</p> PARAMETER DESCRIPTION <code>builder</code> <p>A concrete implementation of the generic class <code>IRBuilder</code> for a particular <code>InputType</code>.</p> <p> TYPE: <code>IRBuilder[InputType]</code> </p> RETURNS DESCRIPTION <code>Callable[[InputType], Model]</code> <p>A function that compiles an <code>InputType</code> object to the Qadence-IR (<code>Model</code>).</p> Source code in <code>qadence2_ir/factory.py</code> <pre><code>def ir_compiler_factory(builder: IRBuilder[InputType]) -&gt; Callable[[InputType], Model]:\n    \"\"\"Constructs an IR compiler function for a specific input type by using an `IRBuilder`.\n\n    The factory function uses an `IRBuilder[InputType]` to create an IR compiler function that\n    converts an input of type `InputType` and returns a Model. The IR compiler must be named\n    'compile_to_model' by convention to ensure accessibility to other engines in the framework.\n\n    Args:\n        builder: A concrete implementation of the generic class `IRBuilder` for a particular\n            `InputType`.\n\n    Returns:\n        A function that compiles an `InputType` object to the Qadence-IR (`Model`).\n    \"\"\"\n\n    def ir_compiler(input_obj: InputType) -&gt; Model:\n        register = builder.set_register(input_obj)\n        directives = builder.set_directives(input_obj)\n        settings = builder.settings(input_obj)\n\n        ast = builder.parse_sequence(input_obj)\n        input_variables = extract_inputs_variables(ast)\n        instructions = build_instructions(ast)\n\n        return Model(register, input_variables, instructions, directives, settings)\n\n    return ir_compiler\n</code></pre>"},{"location":"api/factory_tools/","title":"Factory Tools","text":"<p>Tools to process an <code>AST</code> as used by the compiler factory in <code>qadence2-ir.factory</code>.</p> <p>This module defines a collection of functions that manipulate an <code>AST</code>. Using these AST manipulation tools the factory function in <code>qadence2-ir.factory</code> can build the instruction list from a given AST.</p>"},{"location":"api/factory_tools/#qadence2_ir.factory_tools.build_instructions","title":"<code>build_instructions(ast)</code>","text":"<p>Converts an AST into a list of <code>Model</code> instructions.</p> PARAMETER DESCRIPTION <code>ast</code> <p>A parsed tree containing the sequence of instructions to be added to the <code>Model</code>.</p> <p> TYPE: <code>AST</code> </p> RETURNS DESCRIPTION <code>list[QuInstruct | Assign]</code> <p>A list of quantum operations and temporary static single-assigned variables. Temporary</p> <code>list[QuInstruct | Assign]</code> <p>variables store the outcomes of classical operations and are used as arguments for</p> <code>list[QuInstruct | Assign]</code> <p>parametric quantum operations.</p> Source code in <code>qadence2_ir/factory_tools.py</code> <pre><code>def build_instructions(ast: AST) -&gt; list[QuInstruct | Assign]:\n    \"\"\"Converts an AST into a list of `Model` instructions.\n\n    Args:\n        ast: A parsed tree containing the sequence of instructions to be added to the `Model`.\n\n    Returns:\n        A list of quantum operations and temporary static single-assigned variables. Temporary\n        variables store the outcomes of classical operations and are used as arguments for\n        parametric quantum operations.\n    \"\"\"\n\n    instructions, _, _ = reduce(  # type: ignore\n        lambda acc, x: to_instruct(x, *acc), flatten_ast(ast), ([], dict(), 0)  # type: ignore\n    )\n    return instructions\n</code></pre>"},{"location":"api/factory_tools/#qadence2_ir.factory_tools.extract_inputs_variables","title":"<code>extract_inputs_variables(ast)</code>","text":"<p>Convert all the input variables in the AST into allocation instructions.</p> PARAMETER DESCRIPTION <code>ast</code> <p>A parsed tree containing the sequence of instructions to be added to the <code>Model</code>.</p> <p> TYPE: <code>AST</code> </p> RETURNS DESCRIPTION <code>dict[str, Alloc]</code> <p>A dictionary with the variables names as keys and their respective allocation instructions</p> <code>dict[str, Alloc]</code> <p>as values.</p> Source code in <code>qadence2_ir/factory_tools.py</code> <pre><code>def extract_inputs_variables(ast: AST) -&gt; dict[str, Alloc]:\n    \"\"\"Convert all the input variables in the AST into allocation instructions.\n\n    Args:\n        ast: A parsed tree containing the sequence of instructions to be added to the `Model`.\n\n    Returns:\n        A dictionary with the variables names as keys and their respective allocation instructions\n        as values.\n    \"\"\"\n\n    return reduce(to_alloc, filter_ast(lambda x: x.is_input_variable, ast), dict())\n</code></pre>"},{"location":"api/factory_tools/#qadence2_ir.factory_tools.filter_ast","title":"<code>filter_ast(predicate, ast)</code>","text":"<p>Filters the elements of the AST according to the <code>predicate</code> function.</p> PARAMETER DESCRIPTION <code>predicate</code> <p>A function that checks if a specific property is present in the <code>ast</code>.</p> <p> TYPE: <code>Callable[[AST], bool]</code> </p> <code>ast</code> <p>A parsed AST containing the sequence of instructions to be added to the <code>Model</code>.</p> <p> TYPE: <code>AST</code> </p> RETURNS DESCRIPTION <code>Iterable[AST]</code> <p>An iterable and flattened version of the AST that contains the selected elements.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; ast = AST.div(AST.numeric(2), AST.callable(\"fn\", AST.numeric(3)))\n&gt;&gt;&gt; list(filter_ast(lambda x: x.is_numeric, ast))\n[AST.numeric(2), AST.numeric(3)]\n</code></pre> Source code in <code>qadence2_ir/factory_tools.py</code> <pre><code>def filter_ast(predicate: Callable[[AST], bool], ast: AST) -&gt; Iterable[AST]:\n    \"\"\"Filters the elements of the AST according to the `predicate` function.\n\n    Args:\n        predicate: A function that checks if a specific property is present in the `ast`.\n        ast: A parsed AST containing the sequence of instructions to be added to the `Model`.\n\n    Returns:\n        An iterable and flattened version of the AST that contains the selected elements.\n\n    Example:\n\n    ```python\n    &gt;&gt;&gt; ast = AST.div(AST.numeric(2), AST.callable(\"fn\", AST.numeric(3)))\n    &gt;&gt;&gt; list(filter_ast(lambda x: x.is_numeric, ast))\n    [AST.numeric(2), AST.numeric(3)]\n    ```\n    \"\"\"\n\n    if predicate(ast):\n        yield ast\n\n    else:\n        for arg in ast.args:\n            if isinstance(arg, AST):\n                for term in filter_ast(predicate, arg):\n                    yield term\n</code></pre>"},{"location":"api/factory_tools/#qadence2_ir.factory_tools.flatten_ast","title":"<code>flatten_ast(ast)</code>","text":"<p>Returns an iterable and flattened version of the AST.</p> PARAMETER DESCRIPTION <code>ast</code> <p>A parsed tree containing the sequence of instructions to be added to the <code>Model</code>.</p> <p> TYPE: <code>AST</code> </p> RETURNS DESCRIPTION <code>Iterable[AST]</code> <p>An iterable and flattened version of the AST. The arguments of operations/functions will</p> <code>Iterable[AST]</code> <p>appear before the operation/function.</p> <p>Example: <pre><code>&gt;&gt;&gt; ast = AST.div(AST.numeric(2), AST.callable(\"fn\", AST.numeric(3)))\n&gt;&gt;&gt; list(flatten_ast(ast))\n[\n    AST.numeric(2),\n    AST.numeric(3),\n    AST.callable(\"fn\", AST.numeric(3)),\n    AST.binar_op(\"/\", AST.numeric(2), AST.callable(\"fn\", AST.numeric(3))),\n]\n</code></pre></p> Source code in <code>qadence2_ir/factory_tools.py</code> <pre><code>def flatten_ast(ast: AST) -&gt; Iterable[AST]:\n    \"\"\"Returns an iterable and flattened version of the AST.\n\n    Args:\n        ast: A parsed tree containing the sequence of instructions to be added to the `Model`.\n\n    Returns:\n        An iterable and flattened version of the AST. The arguments of operations/functions will\n        appear before the operation/function.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; ast = AST.div(AST.numeric(2), AST.callable(\"fn\", AST.numeric(3)))\n    &gt;&gt;&gt; list(flatten_ast(ast))\n    [\n        AST.numeric(2),\n        AST.numeric(3),\n        AST.callable(\"fn\", AST.numeric(3)),\n        AST.binar_op(\"/\", AST.numeric(2), AST.callable(\"fn\", AST.numeric(3))),\n    ]\n    ```\n    \"\"\"\n    # TODO update example because binar_op is not supported\n\n    for arg in ast.args:\n        if isinstance(arg, AST):\n            for term in flatten_ast(arg):\n                yield term\n\n    yield ast\n</code></pre>"},{"location":"api/factory_tools/#qadence2_ir.factory_tools.to_alloc","title":"<code>to_alloc(inputs, ast)</code>","text":"<p>If the <code>ast</code> is an input variable, add it to the inputs to be allocated if not present yet.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>A dictionary containing pairs of variables and their allocation instructions, which are already allocated.</p> <p> TYPE: <code>dict[str, Alloc]</code> </p> <code>ast</code> <p>A parsed tree containing the sequence of instructions to be added to the <code>Model</code>.</p> <p> TYPE: <code>AST</code> </p> <p>Return     An updated dictionary containing pairs of variables and their allocation instructions. If     the <code>ast</code> is an input variable, it is added to the dictionary. Otherwise, the dictionary is     returned unchanged.</p> Source code in <code>qadence2_ir/factory_tools.py</code> <pre><code>def to_alloc(inputs: dict[str, Alloc], ast: AST) -&gt; dict[str, Alloc]:\n    \"\"\"If the `ast` is an input variable, add it to the inputs to be allocated if not present yet.\n\n    Args:\n        inputs: A dictionary containing pairs of variables and their allocation instructions, which\n            are already allocated.\n        ast: A parsed tree containing the sequence of instructions to be added to the `Model`.\n\n    Return\n        An updated dictionary containing pairs of variables and their allocation instructions. If\n        the `ast` is an input variable, it is added to the dictionary. Otherwise, the dictionary is\n        returned unchanged.\n    \"\"\"\n\n    if ast.is_input_variable and ast.head not in inputs:\n        name = ast.head\n        size = ast.args[0]\n        trainable = ast.args[1]\n\n        inputs[name] = Alloc(size, trainable, **ast.attrs)\n\n    return inputs\n</code></pre>"},{"location":"api/factory_tools/#qadence2_ir.factory_tools.to_instruct","title":"<code>to_instruct(ast, instructions_list, memoise, single_assign_index)</code>","text":"<p>Adds the <code>ast</code> to the <code>instructions_list</code> if it is a <code>Call</code> or <code>QuInstruct</code>.</p> <p>When the <code>ast</code> is a classical function, it uses the <code>single_assign_index</code> to assign the call to a temporary variable using memoisation to avoid duplicated assignments. If the <code>ast</code> is a quantum instruction, the instruction will be added to the instruction list.</p> PARAMETER DESCRIPTION <code>ast</code> <p>A parsed tree containing the sequence of instructions to be added to the <code>Model</code>.</p> <p> TYPE: <code>AST</code> </p> <code>instructions_list</code> <p>A list of quantum operations and temporary static single-assigned variables.</p> <p> TYPE: <code>list[QuInstruct | Assign]</code> </p> <code>memoise</code> <p>A dictionary containing pairs of AST objects and the respective temporary variables they were assigned to.</p> <p> TYPE: <code>dict[AST, Load]</code> </p> <code>single_assign_index</code> <p>The index to be used by the next temporary variable assignement. Tempmorary variables are labled from \"%0\" to \"%n\".</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>list[QuInstruct | Assign]</code> <p>A tuple consisting of an updated list of instructions and assignments, a dictionary of pairs</p> <code>dict[AST, Load]</code> <p>of AST objects and temporary variables, and the updated index for the next assignment.</p> Source code in <code>qadence2_ir/factory_tools.py</code> <pre><code>def to_instruct(\n    ast: AST,\n    instructions_list: list[QuInstruct | Assign],\n    memoise: dict[AST, Load],\n    single_assign_index: int,\n) -&gt; tuple[list[QuInstruct | Assign], dict[AST, Load], int]:\n    \"\"\"Adds the `ast` to the `instructions_list` if it is a `Call` or `QuInstruct`.\n\n    When the `ast` is a classical function, it uses the `single_assign_index` to assign the call to\n    a temporary variable using memoisation to avoid duplicated assignments. If the `ast` is a\n    quantum instruction, the instruction will be added to the instruction list.\n\n    Args:\n        ast: A parsed tree containing the sequence of instructions to be added to the `Model`.\n        instructions_list: A list of quantum operations and temporary static single-assigned\n            variables.\n        memoise: A dictionary containing pairs of AST objects and the respective temporary\n            variables they were assigned to.\n        single_assign_index: The index to be used by the next temporary variable assignement.\n            Tempmorary variables are labled from \"%0\" to \"%n\".\n\n    Returns:\n        A tuple consisting of an updated list of instructions and assignments, a dictionary of pairs\n        of AST objects and temporary variables, and the updated index for the next assignment.\n    \"\"\"\n\n    if ast in memoise or ast.is_numeric or ast.is_support or ast.is_sequence:\n        return instructions_list, memoise, single_assign_index\n\n    if ast.is_input_variable:\n        memoise[ast] = Load(ast.head)\n        return instructions_list, memoise, single_assign_index\n\n    args = []\n    for arg in ast.args:\n        if isinstance(arg, AST):\n            if arg.is_numeric:\n                args.append(arg.args[0])\n            elif arg.is_support:\n                args.append(Support(target=arg.args[0], control=arg.args[1]))\n            else:\n                args.append(memoise[arg])\n\n    if ast.is_callable:\n        label = f\"%{single_assign_index}\"\n        instructions_list.append(Assign(label, Call(ast.head, *args)))\n        memoise[ast] = Load(label)\n        single_assign_index += 1\n\n    else:\n        instructions_list.append(QuInstruct(ast.head, *args, **ast.attrs))\n\n    return instructions_list, memoise, single_assign_index\n</code></pre>"},{"location":"api/irast/","title":"IRAST","text":"<p>Definition of the abstract syntax tree (AST) for Qadence 2 IR.</p> <p>This module defines the abstract syntax tree (AST) in Qadence 2 IR. The AST is used in the front- end to IR compilation. Implementations of <code>IRBuilder</code>, defined in <code>qadence2-ir.irbuilder</code>, translate front-end code to the AST defined here. Then, the tools in <code>qadence2-ir.factory_tools</code> can be used to manipulate an <code>AST</code> instance and build valid IR instructions from the AST.</p>"},{"location":"api/irast/#qadence2_ir.irast.AST","title":"<code>AST</code>","text":"<p>Represents an instruction sequence as an abstract syntax tree (AST).</p> <p>The initialization of this class must be done using the specific constructors.</p> <p>Constructors:</p> <ul> <li>AST.numeric(value): For numerical values.</li> <li>AST.input_variable(name, size, trainable): For literal variables.</li> <li>AST.callable(fn_name, *args): For classical functions.</li> <li>AST.support(target, control): For qubit indices.</li> <li>AST.quantum_op(name, support, *args): For quantum operators with and without parameters.</li> <li>AST.sequence(*q_ops): For sequences of quantum operations.</li> <li>AST.add(lhs, rhs): For addition, lhs + rhs.</li> <li>AST.sub(lhs, rhs): For subtraction, lhs - rhs.</li> <li>AST.mul(lhs, rhs): For multiplication, lhs * rhs.</li> <li>AST.div(lhs, rhs): For division, lhs / rhs.</li> <li>AST.rem(lhs, rhs): For remainder, lhs % rhs.</li> <li>AST.pow(base, power): For power, base ** power.</li> </ul>"},{"location":"api/irast/#qadence2_ir.irast.AST.__construct__","title":"<code>__construct__(tag, head, *args, **attrs)</code>  <code>classmethod</code>","text":"<p>Base constructor method.</p> <p>To void arbitrary initialization, this class must be initialized with one of the standard constructors provided. This method hides the initialization from the regular <code>__new__</code> to enforce that.</p> PARAMETER DESCRIPTION <code>tag</code> <p>A Tag indicating the AST type. Has one of the following values: <code>QuantumOperator</code>, <code>Sequence</code>, <code>Support</code>, <code>Call</code>, <code>InputVariable</code>, <code>Numeric</code>.</p> <p> TYPE: <code>Tag</code> </p> <code>head</code> <p>A string identifier of the AST object.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Optional arguments for specific constructors.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>attrs</code> <p>Optional attributes for specific constructors.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ast</code> <p>A newly constructed AST object.</p> <p> TYPE: <code>AST</code> </p> Source code in <code>qadence2_ir/irast.py</code> <pre><code>@classmethod\ndef __construct__(cls, tag: Tag, head: str, *args: Any, **attrs: Any) -&gt; AST:\n    \"\"\"Base constructor method.\n\n    To void arbitrary initialization, this class must be initialized with one of the standard\n    constructors provided. This method hides the initialization from the regular `__new__` to\n    enforce that.\n\n    Args:\n        tag: A Tag indicating the AST type. Has one of the following values: `QuantumOperator`,\n            `Sequence`, `Support`, `Call`, `InputVariable`, `Numeric`.\n        head: A string identifier of the AST object.\n        args: Optional arguments for specific constructors.\n        attrs: Optional attributes for specific constructors.\n\n    Returns:\n        ast: A newly constructed AST object.\n    \"\"\"\n\n    token = super().__new__(cls)\n    token._tag = tag\n    token._head = head\n    token._args = args\n    token._attrs = attrs\n    return token\n</code></pre>"},{"location":"api/irast/#qadence2_ir.irast.AST.add","title":"<code>add(lhs, rhs)</code>  <code>classmethod</code>","text":"<p>Create an AST-arithmetic addition.</p> PARAMETER DESCRIPTION <code>lhs</code> <p>Left-hand side operand.</p> <p> TYPE: <code>AST</code> </p> <code>rhs</code> <p>Right-hand side operand.</p> <p> TYPE: <code>AST</code> </p> RETURNS DESCRIPTION <code>ast</code> <p>An AST callable adding <code>lhs</code> and <code>rhs</code>.</p> <p> TYPE: <code>AST</code> </p> Source code in <code>qadence2_ir/irast.py</code> <pre><code>@classmethod\ndef add(cls, lhs: AST, rhs: AST) -&gt; AST:\n    \"\"\"Create an AST-arithmetic addition.\n\n    Args:\n        lhs: Left-hand side operand.\n        rhs: Right-hand side operand.\n\n    Returns:\n        ast: An AST callable adding `lhs` and `rhs`.\n    \"\"\"\n\n    return cls.callable(\"add\", lhs, rhs)\n</code></pre>"},{"location":"api/irast/#qadence2_ir.irast.AST.callable","title":"<code>callable(name, *args)</code>  <code>classmethod</code>","text":"<p>Create an AST-function object.</p> PARAMETER DESCRIPTION <code>name</code> <p>The function name.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Arguments to be passed to the function.</p> <p> TYPE: <code>AST</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ast</code> <p>A callable AST.</p> <p> TYPE: <code>AST</code> </p> Source code in <code>qadence2_ir/irast.py</code> <pre><code>@classmethod\ndef callable(cls, name: str, *args: AST) -&gt; AST:\n    \"\"\"Create an AST-function object.\n\n    Args:\n        name: The function name.\n        args: Arguments to be passed to the function.\n\n    Returns:\n        ast: A callable AST.\n    \"\"\"\n\n    return cls.__construct__(cls.Tag.Call, name, *args)\n</code></pre>"},{"location":"api/irast/#qadence2_ir.irast.AST.div","title":"<code>div(lhs, rhs)</code>  <code>classmethod</code>","text":"<p>Create an AST-arithmetic division.</p> PARAMETER DESCRIPTION <code>lhs</code> <p>Left-hand side operand.</p> <p> TYPE: <code>AST</code> </p> <code>rhs</code> <p>Right-hand side operand.</p> <p> TYPE: <code>AST</code> </p> RETURNS DESCRIPTION <code>ast</code> <p>An AST callable dividing <code>lhs</code> by <code>rhs</code>.</p> <p> TYPE: <code>AST</code> </p> Source code in <code>qadence2_ir/irast.py</code> <pre><code>@classmethod\ndef div(cls, lhs: AST, rhs: AST) -&gt; AST:\n    \"\"\"Create an AST-arithmetic division.\n\n    Args:\n        lhs: Left-hand side operand.\n        rhs: Right-hand side operand.\n\n    Returns:\n        ast: An AST callable dividing `lhs` by `rhs`.\n    \"\"\"\n\n    return cls.callable(\"div\", lhs, rhs)\n</code></pre>"},{"location":"api/irast/#qadence2_ir.irast.AST.input_variable","title":"<code>input_variable(name, size, trainable, **attributes)</code>  <code>classmethod</code>","text":"<p>Create an AST-input variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>The variable's name.</p> <p> TYPE: <code>str</code> </p> <code>size</code> <p>Number of slots to be reserved for the variable, 1 for scalar values and n&gt;1 for array variables.</p> <p> TYPE: <code>int</code> </p> <code>trainable</code> <p>A boolean flag to indicate if the variable is intend to be optimized or used as a constant during the run.</p> <p> TYPE: <code>bool</code> </p> <code>attributes</code> <p>Extra flags, values or dictionaries that can provide more context to the backends.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ast</code> <p>An input variable AST.</p> <p> TYPE: <code>AST</code> </p> Source code in <code>qadence2_ir/irast.py</code> <pre><code>@classmethod\ndef input_variable(cls, name: str, size: int, trainable: bool, **attributes: Any) -&gt; AST:\n    \"\"\"Create an AST-input variable.\n\n    Args:\n        name: The variable's name.\n        size: Number of slots to be reserved for the variable, 1 for scalar values and n&gt;1 for\n            array variables.\n        trainable: A boolean flag to indicate if the variable is intend to be optimized or\n            used as a constant during the run.\n        attributes: Extra flags, values or dictionaries that can provide more context to the\n            backends.\n\n    Returns:\n        ast: An input variable AST.\n    \"\"\"\n\n    return cls.__construct__(cls.Tag.InputVariable, name, size, trainable, **attributes)\n</code></pre>"},{"location":"api/irast/#qadence2_ir.irast.AST.mul","title":"<code>mul(lhs, rhs)</code>  <code>classmethod</code>","text":"<p>Create an AST-arithmetic multiplication.</p> PARAMETER DESCRIPTION <code>lhs</code> <p>Left-hand side operand.</p> <p> TYPE: <code>AST</code> </p> <code>rhs</code> <p>Right-hand side operand.</p> <p> TYPE: <code>AST</code> </p> RETURNS DESCRIPTION <code>ast</code> <p>An AST callable multiplying <code>lhs</code> and <code>rhs</code>.</p> <p> TYPE: <code>AST</code> </p> Source code in <code>qadence2_ir/irast.py</code> <pre><code>@classmethod\ndef mul(cls, lhs: AST, rhs: AST) -&gt; AST:\n    \"\"\"Create an AST-arithmetic multiplication.\n\n    Args:\n        lhs: Left-hand side operand.\n        rhs: Right-hand side operand.\n\n    Returns:\n        ast: An AST callable multiplying `lhs` and `rhs`.\n    \"\"\"\n\n    return cls.callable(\"mul\", lhs, rhs)\n</code></pre>"},{"location":"api/irast/#qadence2_ir.irast.AST.numeric","title":"<code>numeric(value)</code>  <code>classmethod</code>","text":"<p>Create an AST-numeric object.</p> PARAMETER DESCRIPTION <code>value</code> <p>Numerical value to be converted in the Qadence2-IR AST.</p> <p> TYPE: <code>complex | float</code> </p> RETURNS DESCRIPTION <code>ast</code> <p>A numerical value AST.</p> <p> TYPE: <code>AST</code> </p> Source code in <code>qadence2_ir/irast.py</code> <pre><code>@classmethod\ndef numeric(cls, value: complex | float) -&gt; AST:\n    \"\"\"Create an AST-numeric object.\n\n    Args:\n        value: Numerical value to be converted in the Qadence2-IR AST.\n\n    Returns:\n        ast: A numerical value AST.\n    \"\"\"\n\n    return cls.__construct__(cls.Tag.Numeric, \"\", value)\n</code></pre>"},{"location":"api/irast/#qadence2_ir.irast.AST.pow","title":"<code>pow(base, power)</code>  <code>classmethod</code>","text":"<p>Create an AST-arithmetic power.</p> PARAMETER DESCRIPTION <code>base</code> <p>Base operand.</p> <p> TYPE: <code>AST</code> </p> <code>power</code> <p>Power operand.</p> <p> TYPE: <code>AST</code> </p> RETURNS DESCRIPTION <code>ast</code> <p>An AST callable of <code>base</code> to the power <code>power</code>.</p> <p> TYPE: <code>AST</code> </p> Source code in <code>qadence2_ir/irast.py</code> <pre><code>@classmethod\ndef pow(cls, base: AST, power: AST) -&gt; AST:\n    \"\"\"Create an AST-arithmetic power.\n\n    Args:\n        base: Base operand.\n        power: Power operand.\n\n    Returns:\n        ast: An AST callable of `base` to the power `power`.\n    \"\"\"\n\n    return cls.callable(\"pow\", base, power)\n</code></pre>"},{"location":"api/irast/#qadence2_ir.irast.AST.quantum_op","title":"<code>quantum_op(name, target, control, *args, **attributes)</code>  <code>classmethod</code>","text":"<p>Create an AST-quantum operator.</p> PARAMETER DESCRIPTION <code>name</code> <p>Operator's name.</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>A tuple of indices a quantum operator is acting on.</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>control</code> <p>A tuple of indices a quantum operator uses as control qubits.</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>args</code> <p>Arguments to be passed to parameteric quantum operators. Non-parametric operators like Puali gates are treated as a parametric operator with no arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>attributes</code> <p>Extra flags, values or dictionaries that can provide more context to the backends.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ast</code> <p>A quantum operator AST.</p> <p> TYPE: <code>AST</code> </p> Source code in <code>qadence2_ir/irast.py</code> <pre><code>@classmethod\ndef quantum_op(\n    cls,\n    name: str,\n    target: tuple[int, ...],\n    control: tuple[int, ...],\n    *args: Any,\n    **attributes: Any,\n) -&gt; AST:\n    \"\"\"Create an AST-quantum operator.\n\n    Args:\n        name: Operator's name.\n        target: A tuple of indices a quantum operator is acting on.\n        control: A tuple of indices a quantum operator uses as control qubits.\n        args: Arguments to be passed to parameteric quantum operators. Non-parametric\n            operators like Puali gates are treated as a parametric operator with no arguments.\n        attributes: Extra flags, values or dictionaries that can provide more context to the\n            backends.\n\n    Returns:\n        ast: A quantum operator AST.\n    \"\"\"\n\n    support = cls.support(target, control)\n    return cls.__construct__(cls.Tag.QuantumOperator, name, support, *args, **attributes)\n</code></pre>"},{"location":"api/irast/#qadence2_ir.irast.AST.rem","title":"<code>rem(lhs, rhs)</code>  <code>classmethod</code>","text":"<p>Create an AST-arithmetic remainder.</p> PARAMETER DESCRIPTION <code>lhs</code> <p>Left-hand side operand.</p> <p> TYPE: <code>AST</code> </p> <code>rhs</code> <p>Right-hand side operand.</p> <p> TYPE: <code>AST</code> </p> RETURNS DESCRIPTION <code>ast</code> <p>An AST callable; remainder or <code>lhs</code> and <code>rhs</code>.</p> <p> TYPE: <code>AST</code> </p> Source code in <code>qadence2_ir/irast.py</code> <pre><code>@classmethod\ndef rem(cls, lhs: AST, rhs: AST) -&gt; AST:\n    \"\"\"Create an AST-arithmetic remainder.\n\n    Args:\n        lhs: Left-hand side operand.\n        rhs: Right-hand side operand.\n\n    Returns:\n        ast: An AST callable; remainder or `lhs` and `rhs`.\n    \"\"\"\n\n    return cls.callable(\"rem\", lhs, rhs)\n</code></pre>"},{"location":"api/irast/#qadence2_ir.irast.AST.sequence","title":"<code>sequence(*quantum_operators)</code>  <code>classmethod</code>","text":"<p>Create an AST-sequence of quantum operators objects.</p> PARAMETER DESCRIPTION <code>quantum_operators</code> <p>Sequence of quantum operators to be applied by the backend in the given order.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ast</code> <p>An AST-sequence of quantum operators.</p> <p> TYPE: <code>AST</code> </p> Source code in <code>qadence2_ir/irast.py</code> <pre><code>@classmethod\ndef sequence(cls, *quantum_operators: Any) -&gt; AST:\n    \"\"\"Create an AST-sequence of quantum operators objects.\n\n    Args:\n        quantum_operators: Sequence of quantum operators to be applied by the backend in the\n            given order.\n\n    Returns:\n        ast: An AST-sequence of quantum operators.\n    \"\"\"\n\n    return cls.__construct__(cls.Tag.Sequence, \"\", *quantum_operators)\n</code></pre>"},{"location":"api/irast/#qadence2_ir.irast.AST.sub","title":"<code>sub(lhs, rhs)</code>  <code>classmethod</code>","text":"<p>Create an AST-arithmetic subtraction.</p> PARAMETER DESCRIPTION <code>lhs</code> <p>Left-hand side operand.</p> <p> TYPE: <code>AST</code> </p> <code>rhs</code> <p>Right-hand side operand.</p> <p> TYPE: <code>AST</code> </p> RETURNS DESCRIPTION <code>ast</code> <p>An AST callable subtracting <code>rhs</code> from <code>lhs</code>.</p> <p> TYPE: <code>AST</code> </p> Source code in <code>qadence2_ir/irast.py</code> <pre><code>@classmethod\ndef sub(cls, lhs: AST, rhs: AST) -&gt; AST:\n    \"\"\"Create an AST-arithmetic subtraction.\n\n    Args:\n        lhs: Left-hand side operand.\n        rhs: Right-hand side operand.\n\n    Returns:\n        ast: An AST callable subtracting `rhs` from `lhs`.\n    \"\"\"\n\n    return cls.callable(\"sub\", lhs, rhs)\n</code></pre>"},{"location":"api/irast/#qadence2_ir.irast.AST.support","title":"<code>support(target, control)</code>  <code>classmethod</code>","text":"<p>Create an AST-support object used to indicate to which qubits a quantum operation is applied.</p> PARAMETER DESCRIPTION <code>target</code> <p>A tuple of indices a quantum operator is acting on.</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>control</code> <p>A tuple of indices a quantum operator uses as control qubits.</p> <p> TYPE: <code>tuple[int, ...]</code> </p> RETURNS DESCRIPTION <code>ast</code> <p>A support AST.</p> <p> TYPE: <code>AST</code> </p> Source code in <code>qadence2_ir/irast.py</code> <pre><code>@classmethod\ndef support(cls, target: tuple[int, ...], control: tuple[int, ...]) -&gt; AST:\n    \"\"\"Create an AST-support object used to indicate to which qubits a quantum operation is\n    applied.\n\n    Args:\n        target: A tuple of indices a quantum operator is acting on.\n        control: A tuple of indices a quantum operator uses as control qubits.\n\n    Returns:\n        ast: A support AST.\n    \"\"\"\n\n    return cls.__construct__(cls.Tag.Support, \"\", target, control)\n</code></pre>"},{"location":"api/irbuilder/","title":"IR Builder","text":"<p>Defines an ABC for implementing IR builders.</p> <p>This module defines the interface to be used by Qadence 2 IR front-ends to compile to IR. A front- end must implement an <code>IRBuilder</code> for the front-end specific input type, so that <code>ir_compiler_factory</code>, defined in <code>qadence2-ir.factory</code> can generate a compiler function specific to the front-end.</p>"},{"location":"api/irbuilder/#qadence2_ir.irbuilder.IRBuilder","title":"<code>IRBuilder</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[InputType]</code></p> <p>Defines the interface of Qadence 2 IR builders for building IR code from front-end input.</p> <p>An <code>IRBuilder</code> implementation can be used by the <code>ir_compiler_factory</code> function, defined in <code>qadence2-ir.factory</code> to build a compiler function that generates IR code from a specific input type as created by a Qadence 2 front-end. When subclassing this class, specify the <code>InputType</code> that is expected for the implementation, i.e. the object type that the specific front-end generates. This class is responsible for extracting information about the register, directives, other settings and the AST from front-end generated input.</p>"},{"location":"api/irbuilder/#qadence2_ir.irbuilder.IRBuilder.parse_sequence","title":"<code>parse_sequence(input_obj)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns an AST definition that represents the operations in input object.</p> PARAMETER DESCRIPTION <code>input_obj</code> <p>Input for the compilation to IR native to a specific front-end.</p> <p> TYPE: <code>InputType</code> </p> RETURNS DESCRIPTION <code>AST</code> <p>An AST definition that represents the operations defined in an <code>input_obj</code>.</p> Source code in <code>qadence2_ir/irbuilder.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef parse_sequence(input_obj: InputType) -&gt; AST:\n    \"\"\"Returns an AST definition that represents the operations in input object.\n\n    Args:\n        input_obj: Input for the compilation to IR native to a specific front-end.\n\n    Returns:\n        An AST definition that represents the operations defined in an `input_obj`.\n    \"\"\"\n</code></pre>"},{"location":"api/irbuilder/#qadence2_ir.irbuilder.IRBuilder.set_directives","title":"<code>set_directives(input_obj)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns directives based on an input object.</p> PARAMETER DESCRIPTION <code>input_obj</code> <p>Input for the compilation to IR native to a specific front-end.</p> <p> TYPE: <code>InputType</code> </p> RETURNS DESCRIPTION <code>Attributes</code> <p>A specification of all directives that could be extracted from <code>input_obj</code>.</p> Source code in <code>qadence2_ir/irbuilder.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef set_directives(input_obj: InputType) -&gt; Attributes:\n    \"\"\"Returns directives based on an input object.\n\n    Args:\n        input_obj: Input for the compilation to IR native to a specific front-end.\n\n    Returns:\n        A specification of all directives that could be extracted from `input_obj`.\n    \"\"\"\n</code></pre>"},{"location":"api/irbuilder/#qadence2_ir.irbuilder.IRBuilder.set_register","title":"<code>set_register(input_obj)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns a register definition based on an input object.</p> PARAMETER DESCRIPTION <code>input_obj</code> <p>Input for the compilation to IR native to a specific front-end.</p> <p> TYPE: <code>InputType</code> </p> RETURNS DESCRIPTION <code>AllocQubits</code> <p>A register definition that is extracted or inferred from <code>input_obj</code>.</p> Source code in <code>qadence2_ir/irbuilder.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef set_register(input_obj: InputType) -&gt; AllocQubits:\n    \"\"\"Returns a register definition based on an input object.\n\n    Args:\n        input_obj: Input for the compilation to IR native to a specific front-end.\n\n    Returns:\n        A register definition that is extracted or inferred from `input_obj`.\n    \"\"\"\n</code></pre>"},{"location":"api/irbuilder/#qadence2_ir.irbuilder.IRBuilder.settings","title":"<code>settings(input_obj)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns settings based on an input object.</p> PARAMETER DESCRIPTION <code>input_obj</code> <p>Input for the compilation to IR native to a specific front-end.</p> <p> TYPE: <code>InputType</code> </p> RETURNS DESCRIPTION <code>Attributes</code> <p>A specification of all settings that could be extracted from <code>input_obj</code>.</p> Source code in <code>qadence2_ir/irbuilder.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef settings(input_obj: InputType) -&gt; Attributes:\n    \"\"\"Returns settings based on an input object.\n\n    Args:\n        input_obj: Input for the compilation to IR native to a specific front-end.\n\n    Returns:\n        A specification of all settings that could be extracted from `input_obj`.\n    \"\"\"\n</code></pre>"},{"location":"api/types/","title":"Types","text":"<p>Definition of all types supported in the IR.</p> <p>This module is the defacto definition of the IR. A unit of IR code can only consist of instances of the classes defined in this module. An IR <code>Model</code> defines a complete set of instructions for a backend to execute as a task. The instructions a <code>Model</code> can take can be divided into two groups; classical and quantum related instructions:</p> <ul> <li>Classical:<ul> <li><code>Alloc</code>: Allocates memory for holding variable values.</li> <li><code>Assign</code>: Assigns a value to a variable.</li> <li><code>Load</code>: Retrieves a value from a variable.</li> <li><code>Call</code>: Executes a classical function.</li> </ul> </li> <li>Quantum:<ul> <li><code>AllocQubits</code>: Allocates qubits for the computation.</li> <li><code>QuInstruct</code>: Executes a quantum instruction.</li> <li><code>Support</code>: Defines on which qubit(s) and with what role, target or control, a <code>QuInstruct</code>     should act.</li> </ul> </li> </ul>"},{"location":"api/types/#qadence2_ir.types.Alloc","title":"<code>Alloc(size, trainable, **attributes)</code>","text":"<p>Memory allocation for a parameter that is either a scalar value or an array of values.</p> <p>With this class an allocation of memory is made for a parameter that is a scalar value, if <code>size = 1</code> or an array of values of length <code>n</code> if <code>size = n</code>. The type for the allocation is defined by the backend, therefore it is not defined in the IR.</p> PARAMETER DESCRIPTION <code>size</code> <p>Number of values stored in the parameter, if <code>size = 1</code> the parameter is a scalar value if <code>size &gt; 1</code> the parameter is an array of values.</p> <p> TYPE: <code>int</code> </p> <code>trainable</code> <p>Indicates whether the parameter can be changed during a training loop.</p> <p> TYPE: <code>bool</code> </p> <code>attributes</code> <p>Extra flags and information to be used as instructions/suggestions by the backend.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence2_ir/types.py</code> <pre><code>def __init__(self, size: int, trainable: bool, **attributes: Any) -&gt; None:\n    self.size = size\n    self.is_trainable = trainable\n    self.attrs = attributes\n</code></pre>"},{"location":"api/types/#qadence2_ir.types.AllocQubits","title":"<code>AllocQubits(num_qubits, qubit_positions=None, grid_type=None, grid_scale=1.0, connectivity=None, options=None)</code>","text":"<p>Allocation of qubit in a register of a neutral-atom QPU.</p> PARAMETER DESCRIPTION <code>num_qubits</code> <p>Number of qubits, i.e atoms, to be allocated.</p> <p> TYPE: <code>int</code> </p> <code>qubit_positions</code> <p>A list of discrete coordinates for 2D grid, where (0,0) is the position at center of the grid. An empty list will indicate the backend is free to define the topology for devices that implement logical qubits.</p> <p> TYPE: <code>list[tuple[int, int]] | list[int] | None</code> DEFAULT: <code>None</code> </p> <code>grid_type</code> <p>Allows to select the coordinates sets for 2D grids as \"square\" (orthogonal) or \"triangular\" (skew). A \"linear\" will allow the backend to define the shape of the register. When the <code>grid_type</code> is <code>None</code> the backend uses its default structure (particular useful when shuttling is available). Default value is <code>None</code>.</p> <p> TYPE: <code>Literal['linear', 'square', 'triangular'] | None</code> DEFAULT: <code>None</code> </p> <code>grid_scale</code> <p>Adjust the distance between atoms based on a standard distance defined by the backend. Default value is 1.0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>connectivity</code> <p>A dictionary that contains the interaction strength between connected qubit pairs. It is used with compiler backends that implement crossing-lattice strategies or gridless models, such as <code>pyqtorch</code>. If the connectivity graph is available, these backends may ignore the <code>qubit_positions</code>, <code>grid_type</code>, and <code>grid_scale</code> options.</p> <p> TYPE: <code>dict[tuple[int, int], float] | None</code> DEFAULT: <code>None</code> </p> <code>options</code> <p>Extra register related properties that may not be supported by all backends.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence2_ir/types.py</code> <pre><code>def __init__(\n    self,\n    num_qubits: int,\n    qubit_positions: list[tuple[int, int]] | list[int] | None = None,\n    grid_type: Literal[\"linear\", \"square\", \"triangular\"] | None = None,\n    grid_scale: float = 1.0,\n    connectivity: dict[tuple[int, int], float] | None = None,\n    options: dict[str, Any] | None = None,\n) -&gt; None:\n    self.num_qubits = num_qubits\n    self.qubit_positions = qubit_positions or []\n    self.grid_type = grid_type\n    self.grid_scale = grid_scale\n    self.connectivity = connectivity or dict()\n    self.options = options or dict()\n</code></pre>"},{"location":"api/types/#qadence2_ir.types.Assign","title":"<code>Assign(variable_name, value)</code>","text":"<p>Assignment of a value to a variable.</p> PARAMETER DESCRIPTION <code>variable_name</code> <p>The name of the variable to assign a value to.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The value to be assigned to the variable.</p> <p> TYPE: <code>Any</code> </p> Source code in <code>qadence2_ir/types.py</code> <pre><code>def __init__(self, variable_name: str, value: Any) -&gt; None:\n    self.variable = variable_name\n    self.value = value\n</code></pre>"},{"location":"api/types/#qadence2_ir.types.Call","title":"<code>Call(identifier, *args)</code>","text":"<p>Instruction to call a classical function.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>The identifier of the function to call, i.e. its name.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>The arguments that the function should be called with.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> Source code in <code>qadence2_ir/types.py</code> <pre><code>def __init__(self, identifier: str, *args: Any) -&gt; None:\n    self.identifier = identifier\n    self.args = args\n</code></pre>"},{"location":"api/types/#qadence2_ir.types.Load","title":"<code>Load(variable_name)</code>","text":"<p>Instruction to load the value of a variable.</p> PARAMETER DESCRIPTION <code>variable_name</code> <p>The name of the variable to load.</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence2_ir/types.py</code> <pre><code>def __init__(self, variable_name: str) -&gt; None:\n    self.variable = variable_name\n</code></pre>"},{"location":"api/types/#qadence2_ir.types.Model","title":"<code>Model(register, inputs, instructions, directives=None, settings=None)</code>","text":"<p>Aggregates the minimal information to construct sequence of instructions to execute on a QPU.</p> <p>This class defines a unit of IR code. The structure of the class is mainly focused in neutral atoms devices but its agnostic nature may make it suitable for any quantum device.</p> PARAMETER DESCRIPTION <code>register</code> <p>Describes the atomic arrangement of the neutral atom register.</p> <p> TYPE: <code>AllocQubits</code> </p> <code>instructions</code> <p>A list of abstract instructions with their arguments that a backend can use to execute a sequence.</p> <p> TYPE: <code>list[QuInstruct | Assign]</code> </p> <code>directives</code> <p>A dictionary containing QPU related options. For instance, it can be used to set the Rydberg level to be used or whether to allow digital-analog operations in the sequence.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>settings</code> <p>Backend specific configurations where the user can define for instance, the data type like <code>int64</code>.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence2_ir/types.py</code> <pre><code>def __init__(\n    self,\n    register: AllocQubits,\n    inputs: dict[str, Alloc],\n    instructions: list[QuInstruct | Assign],\n    directives: dict[str, Any] | None = None,\n    settings: dict[str, Any] | None = None,\n) -&gt; None:\n    self.register = register\n    self.directives = directives or dict()\n    self.settings = settings or dict()\n    self.inputs = inputs\n    self.instructions = instructions\n</code></pre>"},{"location":"api/types/#qadence2_ir.types.QuInstruct","title":"<code>QuInstruct(name, support, *args, **attributes)</code>","text":"<p>Instruction to apply a quantum operation to one or more qubit(s).</p> PARAMETER DESCRIPTION <code>name</code> <p>The instruction name compatible with the standard instruction set.</p> <p> TYPE: <code>str</code> </p> <code>support</code> <p>The index of qubits to which the instruction is applied to.</p> <p> TYPE: <code>Support</code> </p> <code>args</code> <p>Arguments of the instruction such as angle, duration, amplitude etc.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>attributes</code> <p>Extra flags and information to be used as instructions/suggestions by the backend.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence2_ir/types.py</code> <pre><code>def __init__(self, name: str, support: Support, *args: Any, **attributes: Any):\n    self.name = name\n    self.support = support\n    self.args = args\n    self.attrs = attributes\n</code></pre>"},{"location":"api/types/#qadence2_ir.types.Support","title":"<code>Support(target, control=None)</code>","text":"<p>Instruction that specifies the target and optionally control of a <code>QuInstruct</code>.</p> <p>Generic representation of qubit support, specifying a target and control for a quantum instruction. For single qubit operations, a multiple index support indicates apply the operation for each index in the support. Both target and control lists must be ordered!</p> PARAMETER DESCRIPTION <code>target</code> <p>Index or indices of qubits to which the operation is applied.</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>control</code> <p>Index or indices of qubits which to which the operation is conditioned to.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence2_ir/types.py</code> <pre><code>def __init__(\n    self,\n    target: tuple[int, ...],\n    control: tuple[int, ...] | None = None,\n) -&gt; None:\n    self.target = target\n    self.control = control or ()\n</code></pre>"},{"location":"contents/","title":"Qadence2 IR","text":"<p>Qadence 2 IR is a Pasqal initiative, to define an intermediate representation structure for neutral atom devices. The structure captures the key elements of the platform while remaining agnostic regarding hardware specifications. The goal is to simplify instruction building of analog quantum algorithms, enabling optimized instructions and compilation processes of task-specific algorithms to different platforms. By using an agnostic instruction set, Qadence 2 IR allows digital and analog instructions to work together, extending its usability to the digital-analog paradigm. The IR uses static single-assignment to simplify differentiability when running simulations.</p>"},{"location":"contents/challenges/","title":"Challenges","text":"<p>As pointed out here, digital and analog algorithms diverge in how they handle register topology. Contrary to classical computing, where the resource allocation is typically left to the OS to control, the quantum resources are explicit in this analog quantum computating IR.</p> <p>For digital devices and circuit-based algorithms, the register topology is important mostly during the compilation phase to reduce the number of SWAP gates applied. Analog algorithms and devices, on the other hand, rely on the topology to ensure the proper interaction between qubits regarding connectivity and strength. That led us to consider including the abstract representation of the register (either by unitless coordinates or connectivity graph) as part of the IR.</p> <p>However, register preparation doesn\u2019t represent an instruction in the sense of runtime since it needs to be loaded before the sequence starts and (for analog algorithms) cannot be changed during execution. Even if shuttling is available, the initial register configuration needs to be known to properly evaluate the atoms\u2019 movement since such action will affect the connectivity of the register.</p> <p>Besides the register, other elements like the SLM used to target individual qubits are part of the \u201cbooting\u201d/resources allocation that is not directly connected to the register but cannot be addressed as regular instructions. Still, its presence may affect the behavior of specific pulses, which motivated the inclusion of a \u201cDirectives\u201d section on the IR.</p> <p>Primitive operations are another challenge in neutral atoms. The analog nature of the algorithms and device makes it difficult to clearly define \u201cprimitive operations\u201d. Elementary structures like a pulse corresponding to the neutral atom Hamiltonian and an idle/wait instruction to let the qubits interact under free coupling (without drive).</p> <p>To avoid define a fixed set of operations that may not reflect the hardware capabilities and to avoid constant changes in the IR definition to include new primitives, the instructions\u2019 names are passed as labels like <code>QuInstrunct(\"dyn_pulse\", \u2026)</code> and <code>QuInstruct(\"rx\", \u2026)</code> instead of <code>Pulse(\u2026)</code> and <code>RX(\u2026)</code>. This may change in the future. However, right now, this flexibility allows us to explore the hardware's capabilities without being held by a particular set of instructions.</p>"},{"location":"contents/compute_stack/","title":"Compute Stack","text":"<p>Pasqal\u2019s compute stack comprises four layers, as shown in Figure 1. A user defines the quantum computation using one of the front-ends: Qadence 2 Expressions or PQL. The computation to be executed is processed from layer to layer and eventually executed on the hardware. In each layer, a quantum computation is expressed in a specific data structure. The higher up the layer is in the stack, the more hardware details are abstracted away.</p> <p>The top layer is user-facing, with the highest level of abstraction. For each front-end, a compiler exists that compiles the computation in Qadence 2 IR. See the section IR structure for more details on its definition. The low-level compilation process targets a backend, either a QPU or a simulator, and compiles the computation into code that can run on the targeted backend. The backend itself takes care of executing the computation on the hardware.</p> <p>It's important to note that the Qadence 2 IR layer spreads over the full width of the stack, meaning that all front-ends can compile to it and any backend can be targeted from it. The two-step compilation approach reduces the coupling between elements in the stack significantly and makes the codebase, therefore, more maintainable.</p> <p> Figure 1: The Qadence 2 software stack.</p>"},{"location":"contents/ir_structure/","title":"IR Structure","text":"<p>The main idea for Qadence 2 IR is to provide an abstract neutral atom device model.</p> <p>Neutral atom devices usually rely on absolute values like laser power, atomic spacing in micrometers, and nanosecond pulse duration. Since the interaction between atoms and, therefore, the execution of algorithms in such devices are heavily influenced by those parameters, having a well-tuned algorithm for a specific device is desired. With that in mind, the IR definition should be independent of device-specific parameters, leaving their implementation to the backend. At the same time, the front-end compilation pipeline must build the IR from the algorithm and bridges with the backend at the low-level compilation pipeline, accessing its runtime resources.</p> <p>Analog-relevant data such as the qubit register, parametric symbols and quantum instructions are wrapped in the IR, enabling each backend to handle them case-by-case. In particular, the instructions will provide only minimal information, such as the qubit support and the instruction label, i.e., which quantum operator or instruction is being applied, and the backend must provide some implementation for it.</p> <p>The IR Model is split in four sections:</p> <ul> <li>Inputs</li> <li>Instructions</li> <li>Register</li> <li>Directives</li> </ul> <p>The Inputs section is responsible for declaring the classical data and flagging them as trainable or not. This information is desired to ensure that only the parameters used in the machine learning training steps are considered for differentiability.</p> <p>The Instruction section holds the sequence of classical computation via static single-assignment to avoid duplicate computation and help the differentiability instructions.</p> <p>Quantum operations are passed as labels instead of fixed primitives (see the Challenges section). The IR definition is independent of device-specific parameters and leaves their configuration to the compiler, which builds an IR algorithm into instructions that contain the device-specific parameters.</p> <p>The Register section holds either an abstract description of how the atoms are placed on the register or a connectivity graph, depending on the type of algorithm. Algorithms that don\u2019t require customized registers are allowed to pass only the number of qubits. This process is delegated to the backend compiler to decide the best strategies to organize the atoms whenever possible.</p> <p>The Directives section holds other device critical information for resource allocation like SLM mask target for individual qubit addressability.</p> <p>Resource allocation, such as Registers and Directives, is usually not expected in an intermediate representation. However, as described before, those elements can affect algorithm design and pulse execution. The Challenges section presents more details about them.</p>"},{"location":"getting_started/CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"getting_started/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"getting_started/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"getting_started/CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"getting_started/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"getting_started/CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence 2 IR. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"getting_started/CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence ir, feel free to create an issue on qadence IR's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"getting_started/CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence IR. To contribute, fork the <code>main</code> branch of qadence IR repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button in the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence2-ir</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence2-ir.git\n</code></pre> <p>Next, navigate to your new qadence expressions fork directory and mark the main qadence expressions repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence2-ir.git\n</code></pre>"},{"location":"getting_started/CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence expressions, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence IR tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"getting_started/CONTRIBUTING/#linting-and-testing-workflows","title":"Linting and testing workflows","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"getting_started/LICENSE/","title":"Apache License","text":"<p>Version 2.0, January 2004</p> <p>http://www.apache.org/licenses/</p>"},{"location":"getting_started/LICENSE/#terms-and-conditions-for-use-reproduction-and-distribution","title":"TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION","text":""},{"location":"getting_started/LICENSE/#1-definitions","title":"1. Definitions:","text":"<p>\"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.</p>"},{"location":"getting_started/LICENSE/#2-grant-of-copyright-license","title":"2. Grant of Copyright License.","text":"<p>Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.</p>"},{"location":"getting_started/LICENSE/#3-grant-of-patent-license","title":"3. Grant of Patent License.","text":"<p>Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.</p>"},{"location":"getting_started/LICENSE/#4-redistribution","title":"4. Redistribution.","text":"<p>You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:</p> <ul> <li> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> </li> <li> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> </li> <li> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> </li> <li> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> </li> </ul> <p>You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.</p>"},{"location":"getting_started/LICENSE/#5-submission-of-contributions","title":"5. Submission of Contributions.","text":"<p>Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.</p>"},{"location":"getting_started/LICENSE/#6-trademarks","title":"6. Trademarks.","text":"<p>This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.</p>"},{"location":"getting_started/LICENSE/#7-disclaimer-of-warranty","title":"7. Disclaimer of Warranty.","text":"<p>Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.</p>"},{"location":"getting_started/LICENSE/#8-limitation-of-liability","title":"8. Limitation of Liability.","text":"<p>In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.</p>"},{"location":"getting_started/LICENSE/#9-accepting-warranty-or-additional-liability","title":"9. Accepting Warranty or Additional Liability.","text":"<p>While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.</p>"},{"location":"getting_started/LICENSE/#end-of-terms-and-conditions","title":"END OF TERMS AND CONDITIONS","text":""},{"location":"getting_started/installation/","title":"Installation","text":"<p>Note</p> <p>It is advised to set up a python environment before installing the package, such as venv, hatch, pyenv, conda or poetry. (Qadence 2 in development mode uses <code>hatch</code>).</p> <p>To install the current version of Qadence 2 IR, there are a few options:</p>"},{"location":"getting_started/installation/#installation-from-pypi","title":"Installation from PYPI","text":"<p>On the terminal, type</p> <pre><code>pip install qadence2-ir\n</code></pre>"},{"location":"getting_started/installation/#installation-from-source","title":"Installation from Source","text":"<p>Clone this repository by typing on the terminal</p> <pre><code>git clone https://github.com/pasqal-io/qadence2-ir.git\n</code></pre> <p>Go to <code>qadence2-ir</code> folder and install it using hatch</p> <pre><code>hatch -v shell\n</code></pre> <p>Use hatch environment on your IDE or terminal to use <code>qadence2-ir</code> package.</p>"},{"location":"tutorials/examples/","title":"Examples","text":"<p>The following examples were generate to present some possible algorithms and may not be fully implementable in the hardware at the moment.</p>"},{"location":"tutorials/examples/#example-digital-input","title":"Example digital input.","text":"<pre><code>Model(\n    register = AllocQubits(2),\n    directives = { # for QPU options\n    },\n    inputs = {\n        \"x\": Alloc(1, trainable=True),\n    },\n    instructions = [\n\n        # data encoding\n        Assign(\"%0\", Call(\"mul\", 0.5, Load(\"x\"))),\n        QuInstruction(\"rx\", Support(target=(0,)), Load(\"%0\")),\n\n        # cnot\n        QuInstruction(\"x\", Support(target=(1,), control=(0,))),\n    ],\n)\n</code></pre>"},{"location":"tutorials/examples/#example-digital-analog-input","title":"Example digital-analog input.","text":"<pre><code>Model(\n    register = AllocQubits(4),\n    directives = {\n        \"dmm\": {\n            \"targets\": [0, 1, 2, 3],\n            \"weights\": \"equal\",\n        }\n    },\n    settings = {},\n    inputs = {\n        \"theta\": Alloc(4, trainable=False)\n        \"duration\": Alloc(1, trainable=True)\n        \"omega\": Alloc(5, trainable=True)\n    },\n    instrunctions = [\n        # Tower feature map\n        Assign(\"%0\", Call(\"mul\", 0.31831, Load(\"theta\")),\n        QuInstruct(\"set_dmm\", Support.target_all(), Load(\"%0\"))\n        QuInstruct(\"rx\", Support.target_all(), 1.570796),\n        QuInstruct(\"dyn_local_pulse\", Support.target_all(), 2.0),\n        QuInstruct(\"rx\", Support.target_all(), -1.570796),\n\n        # Entanglement\n        QuInstruct(\"dyn_interact\", Support.target_all(), 2.5),\n\n        # Trainable layer\n        QuInstruct(\"dyn_pulse\", Support.target_all(), Load(\"duration\"), Load(\"omega\"), 0.0, 0.0),\n    ],\n)\n</code></pre>"},{"location":"tutorials/examples/#example-analog-input","title":"Example analog input.","text":"<pre><code>Model(\n    register = AllocQubits(\n        num_qubits = 4,\n        qubits_positions = [\n            (-2, 1), (-1, 0), (0, 0), (1, -1)\n        ],\n\n        # optional parameters\n        grid_type = \"triangular\",\n        grid_scale = 1.0,\n    ),\n    directives = {\n        \"dmm\": {\n            \"targets\": [0, 3],\n            \"weights\": [0.5, 1.0],\n        }\n    },\n    inputs = {\n        \"duration\": Alloc(1, trainable=False, attrs={\"time_parameter\": True}),\n        \"omega\": Alloc(4, trainable=True),\n        \"delta\": Alloc(3, trainable=True),\n    },\n    instrunctions = [\n        QuInstruct(\n            \"dyn_pulse\",\n            Support.target_all(),\n            Load(\"duration\"),\n            Load(\"omega\"),\n            Load(\"delta\"),\n            0.0,  # phase\n        ),\n        QuInstruction(\n            \"dyn_local_phase\",\n            Support(target=(0, 1)),  # match with dmm targets\n            1.2,  # duration\n            attrs={\n                \"concurrent\": True,  # starts with the previous pulse\n            }\n        ),\n    ],\n)\n</code></pre>"},{"location":"tutorials/examples/#example-analog-input-alternative","title":"Example analog input (alternative)","text":"<p>This example is intend to be used with backends that either support crossing-lattice  or similar algorithms, or gridless backends (e.g. PyQ). <pre><code>Model(\n    register = AllocQubits(\n        num_qubits = 4,\n        connectivity = {\n            (0, 1): 1.2,\n            (0, 3): 0.9,\n            (1, 2): 1.4,\n            (2, 3): 2.1,\n        }\n    ),\n    directives = {\n        \"dmm\": {\n            \"targets\": [0, 3],\n            \"weights\": [0.5, 1.0],\n        }\n    },\n    inputs = {\n        \"duration\": Alloc(1, trainable=False, attrs={\"time_parameter\": True}),\n        \"omega\": Alloc(4, trainable=True),\n        \"delta\": Alloc(3, trainable=True),\n    },\n    instrunctions = [\n        QuInstruct(\n            \"dyn_pulse\",\n            Support.target_all(),\n            Load(\"duration\"),\n            Load(\"omega\"),\n            Load(\"delta\"),\n            0.0,  # phase\n        ),\n        QuInstruction(\n            \"dyn_local_phase\",\n            Support(target=(0, 1)),  # match with dmm targets\n            attrs={\n                \"concurrent\": True,  # starts with the previous pulse\n                \"duration\": 1.2,\n            }\n        ),\n    ],\n)\n</code></pre></p> <pre><code>Model(\n    register=AllocQubits(\n        num_qubits=3,\n        connectivity={(0,1): 1., (0,2): .5, (1,2): .5},\n    ),\n    directives={\n        \"dmm\": {\"targets\": [0, 1]}\n    },\n    inputs={\n        't': Alloc(1, trainable=True)\n    },\n    instructions=[\n        # The presence of the `dmm` allows a single qubit operation by\n        # dynamic decoupling the others two qubits.\n        QuInstruct('x', Support(target=(2,))),\n\n        Assign('%0', Mul(1.57, Load('t')),\n        QuInstruct('dyn_pulse', target_all(), Load('%0'), 1.0),\n    ],\n)\n</code></pre>"}]}